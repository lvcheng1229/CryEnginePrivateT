#include "Common.cfi"
#include "ShadeLib.cfi"

Texture2D           deviceZTex          : register(t0); 
RWBuffer<uint>      vsmTileFlags        : register(u0);

cbuffer CBTileFlagGen : register(b0)
{
	struct 
	{
		float4x4 invViewProj;
        float4x4 lightViewProj;

        float4 deviceZTexSize;
        int4 vsmTileNum;
	} c_TileFlagGenConstants;
};

[numthreads(16, 16, 1)]
void VSMTileFlagGenCS(uint2 DispatchThreadID :SV_DispatchThreadID)
{
    float2 uvdeviceZ = DispatchThreadID * c_TileFlagGenConstants.deviceZTexSize.zw;

    if(uvdeviceZ.x > 1.0f || uvdeviceZ.y > 1.0f)
    {
        return;
    }

    float deviceZ = deviceZTex.Load(int3(DispatchThreadID,0));

    float2 screenPos = uvdeviceZ * 2.0f - 1.0f; 
    screenPos.y *= -1.0f;

    float4 ndcPos = float4(screenPos, deviceZ, 1.0);
    
    float4 worldPosition = mul(c_TileFlagGenConstants.invViewProj, ndcPos);
    worldPosition.xyz /= worldPosition.w;

    float4 shadowScreenPOS = mul(float4(worldPosition,1.0),c_TileFlagGenConstants.lightViewProj);
    shadowScreenPOS.xyz /= shadowScreenPOS.w;

    float2 uvVSM = shadowScreenPOS.xy; 
    uvVSM.y *= -1.0;
    uvVSM = uvVSM * 0.5 + 0.5f;

    if(all(abs(uvVSM) < 1.0f))
    {
        uint2 uvBuffer = uvVSM * c_TileFlagGenConstants.vsmTileNum.xy;
        uint bufferIndex = uvBuffer.y * c_TileFlagGenConstants.vsmTileNum.x + uvBuffer.x;

        vsmTileFlags[bufferIndex] = 1;
    }
}


struct vtxOut
{
  OUT_HPOS_IN_WPOS
  float4 baseTC     : TEXCOORD0;
};

vtxOut FullscreenTriVS(uint VertexID : SV_VertexID)
{
	vtxOut OUT = (vtxOut)0;
	OUT.HPosition = GetHPos_FromTriVertexID(VertexID);
	OUT.baseTC.xy = GetBaseTC_FromTriVertexID(VertexID);
	return OUT;
}

Buffer<uint>    visualizeBuffer    : register(t0);
float4 visualizeBufferSize;

pixout VisualizeBufferPS(vtxOut IN)
{
    pixout OUT;
    uint2 uvCoord = IN.baseTC.xy * visualizeBufferSize.xy;
    OUT.Color = float4(visualizeBuffer[uvCoord.y * visualizeBufferSize.x + uvCoord.x],0.0,0.0,1.0);
    return OUT;
}

technique VSMTileFlagGen
{
	pass p0
	{
		ComputeShader = VSMTileFlagGenCS();
	}
};


technique VSMVisualizeBuffer
{
	pass p0
	{
		VertexShader = FullscreenTriVS();
		PixelShader = VisualizeBufferPS();
	}
};