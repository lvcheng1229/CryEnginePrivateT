// Copyright 2019-2021 Crytek GmbH / Crytek Group. All rights reserved.
// Autogenerated using GFxShaderMaker modified by Crytek (depot\SDK\3rdParty\Scaleform-4.6.34\Apps\Tools\GFxShaderMaker)

Texture2D cry_tex0 : register(t0);
Texture2D cry_tex1 : register(t1);
Texture2D cry_tex2 : register(t2);
Texture2D cry_tex3 : register(t3);
SamplerState cry_sampler0 : register(s0);
SamplerState cry_sampler1 : register(s1);
SamplerState cry_sampler2 : register(s2);
SamplerState cry_sampler3 : register(s3);

#define SF_RENDER_MAX_BATCHES 24

#if %SF_BATCH && %SF_FACTORS
    #define GET_INSTANCE [input.afactor.b * 255.01f + 0.1f]
#elif %SF_INSTANCED || %SF_BATCH
    #define GET_INSTANCE [input.vbatch]
#else
    #define GET_INSTANCE 
#endif


struct VS_INPUT
{
#if %SF_VERTEX || %SF_TEXTGVERTEX || %SF_ATEXTGVERTEX || %SF_TEXT
    float4 acolor : COLOR0;
#endif
#if %SF_FACTORS
    float4 afactor : COLOR1;
#endif
#if %SF_TEXT || %SF_TEXUV || %SF_ATEXUV
    float2 atc : TEXCOORD0;
#endif
#if %SF_POSITION2D || %SF_POSITION3D || %SF_TEXTG || %SF_TEXTGTEXTG || %SF_ATEXTGATEXTG || %SF_TEXTGVERTEX || %SF_ATEXTGVERTEX || %SF_TEXTGVERTEXONLY || %SF_DEPTHMASKCLEAR || %SF_TEXTGTEXTGVERTEXONLY || %SF_TEXTGTEXTGTEXTGVERTEXONLY
    float4 pos : POSITION;
#endif
#if %SF_INSTANCED
    uint vbatch : SV_InstanceID;
#elif %SF_BATCH && !%SF_FACTORS
    uint vbatch : COLOR2;
#endif
};

cbuffer CB_BASE : register(b0)
{
#if %SF_TEXDENSITY
    float4 mipLevels;
#endif
#if %SF_TEXDENSITY
    float2 textureDims;
#endif
struct
{
#if %SF_CXFORM || %SF_CXFORMAC
    float4 cxadd;
#endif
#if %SF_CXFORM || %SF_CXFORMAC
    float4 cxmul;
#endif
#if %SF_POSITION2D
    float4 mvp[2];
#endif
#if %SF_POSITION3D
    float4 mvp[4];
#endif
#if %SF_TEXTG || %SF_TEXTGVERTEX || %SF_ATEXTGVERTEX || %SF_TEXTGVERTEXONLY
    float4 texgen[2];
#endif
#if %SF_TEXTGTEXTG || %SF_ATEXTGATEXTG
    float4 texgen[4];
#endif
} cb_base
#if %SF_BATCH || %SF_INSTANCED
[SF_RENDER_MAX_BATCHES]
#endif
;
};

struct PS_BASE
{
#if %SF_VERTEX || %SF_TEXTGVERTEX || %SF_ATEXTGVERTEX
    float4 color : COLOR0;
#endif
#if %SF_FACTORS
    half4 factor : COLOR1;
#endif
#if %SF_CXFORM || %SF_CXFORMAC
    float4 fucxadd : TEXCOORD0;
#endif
#if %SF_CXFORM || %SF_CXFORMAC
    float4 fucxmul : TEXCOORD1;
#endif
#if %SF_TEXTG || %SF_TEXTGTEXTG || %SF_ATEXTGATEXTG || %SF_TEXTGVERTEX || %SF_ATEXTGVERTEX || %SF_TEXTGVERTEXONLY
    half2 tc0 : TEXCOORD2;
#endif
#if %SF_TEXTGTEXTG || %SF_ATEXTGATEXTG
    half2 tc1 : TEXCOORD3;
#endif
#if %SF_POSITION2D || %SF_POSITION3D
    float4 vpos : SV_Position;
#endif
};

void vs_base(VS_INPUT input, out PS_BASE output)
{
#if %SF_POSITION2D
    output.vpos = float4(0,0,0,1);
    output.vpos.x = dot(input.pos, cb_base GET_INSTANCE .mvp[0]);
    output.vpos.y = dot(input.pos, cb_base GET_INSTANCE .mvp[1]);
#endif
#if %SF_POSITION3D
    output.vpos.x = dot(input.pos, cb_base GET_INSTANCE .mvp[0]);
    output.vpos.y = dot(input.pos, cb_base GET_INSTANCE .mvp[1]);
    output.vpos.z = dot(input.pos, cb_base GET_INSTANCE .mvp[2]);
    output.vpos.w = dot(input.pos, cb_base GET_INSTANCE .mvp[3]);
#endif
#if %SF_TEXTG
    output.tc0.x = dot(input.pos, cb_base GET_INSTANCE .texgen[0]);
    output.tc0.y = dot(input.pos, cb_base GET_INSTANCE .texgen[1]);
#endif
#if %SF_VERTEX
    output.color = input.acolor;
#endif
#if %SF_TEXTGTEXTG
    output.tc0.x = dot(input.pos, cb_base GET_INSTANCE .texgen[0]);
    output.tc0.y = dot(input.pos, cb_base GET_INSTANCE .texgen[1]);
    output.tc1.x = dot(input.pos, cb_base GET_INSTANCE .texgen[2]);
    output.tc1.y = dot(input.pos, cb_base GET_INSTANCE .texgen[3]);
#endif
#if %SF_ATEXTGATEXTG
    output.tc0.x = dot(input.pos, cb_base GET_INSTANCE .texgen[0]);
    output.tc0.y = dot(input.pos, cb_base GET_INSTANCE .texgen[1]);
    output.tc1.x = dot(input.pos, cb_base GET_INSTANCE .texgen[2]);
    output.tc1.y = dot(input.pos, cb_base GET_INSTANCE .texgen[3]);
#endif
#if %SF_TEXTGVERTEX
    output.color = input.acolor;
    output.tc0.x = dot(input.pos, cb_base GET_INSTANCE .texgen[0]);
    output.tc0.y = dot(input.pos, cb_base GET_INSTANCE .texgen[1]);
#endif
#if %SF_ATEXTGVERTEX
    output.color = input.acolor;
    output.tc0.x = dot(input.pos, cb_base GET_INSTANCE .texgen[0]);
    output.tc0.y = dot(input.pos, cb_base GET_INSTANCE .texgen[1]);
#endif
#if %SF_CXFORM
    output.fucxadd = cb_base GET_INSTANCE .cxadd;
    output.fucxmul = cb_base GET_INSTANCE .cxmul;
#endif
#if %SF_CXFORMAC
    output.fucxadd = cb_base GET_INSTANCE .cxadd;
    output.fucxmul = cb_base GET_INSTANCE .cxmul;
#endif
#if %SF_TEXTGVERTEXONLY
    output.tc0.x = dot(input.pos, cb_base GET_INSTANCE .texgen[0]);
    output.tc0.y = dot(input.pos, cb_base GET_INSTANCE .texgen[1]);
#endif
#if %SF_FACTORS
      output.factor = input.afactor;
#endif
}

void ps_base(PS_BASE input, out float4 fcolor : SV_Target0)
{
#if %SF_TEXTG
    fcolor = cry_tex0.Sample(cry_sampler0,input.tc0);
#endif
#if %SF_ATEXTG
    fcolor      = cry_tex0.Sample(cry_sampler0, input.tc0);
    fcolor.a    = cry_tex1.Sample(cry_sampler1, input.tc0).r;
#endif
#if %SF_VERTEX
  fcolor = input.color;
#endif
#if %SF_TEXTGTEXTG
    float4 fcolor0 = cry_tex0.Sample(cry_sampler0, input.tc0);
    float4 fcolor1 = cry_tex1.Sample(cry_sampler1, input.tc1);
    fcolor = lerp(fcolor1, fcolor0, input.factor.r);
#endif
#if %SF_ATEXTGATEXTG
    float4 fcolor0 = cry_tex0.Sample(cry_sampler0, input.tc0);
    fcolor0.a = cry_tex1.Sample(cry_sampler1, input.tc0).r;
    float4 fcolor1 = cry_tex2.Sample(cry_sampler2, input.tc1);
    fcolor1.a = cry_tex3.Sample(cry_sampler3, input.tc1).r;
    fcolor = lerp(fcolor1, fcolor0, input.factor.r);
#endif
#if %SF_TEXTGVERTEX
    float4 fcolor0 = cry_tex0.Sample(cry_sampler0,input.tc0);
    float4 fcolor1 = input.color;
    fcolor = lerp(fcolor1, fcolor0, input.factor.r);
#endif
#if %SF_ATEXTGVERTEX
    float4 fcolor0 = cry_tex0.Sample(cry_sampler0,input.tc0);
    fcolor0.a = cry_tex1.Sample(cry_sampler1,input.tc0).r;
    float4 fcolor1 = input.color;
    fcolor = lerp(fcolor1, fcolor0, input.factor.r);
#endif
#if %SF_CXFORM
    fcolor = clamp(fcolor * input.fucxmul + input.fucxadd, 0.0f, 1.0f);
#endif
#if %SF_CXFORMAC
      fcolor = (fcolor * float4(input.fucxmul.rgb,1)) * input.fucxmul.a;
      fcolor += input.fucxadd * fcolor.a;
      fcolor = clamp(fcolor, 0.0f, 1.0f);
#endif
#if %SF_EALPHA
    fcolor.a *= input.factor.a;
#endif
#if %SF_MUL
    fcolor.rgb = fcolor.rgb * fcolor.a;
#endif
#if %SF_INV
    fcolor.rgb = float3(fcolor.a, fcolor.a, fcolor.a);
#endif
#if %SF_INVERSEGAMMA
      fcolor = fcolor;
#endif
#if %SF_TEXDENSITY
    float2 dx = ddx(input.tc0 * textureDims.x);
    float2 dy = ddy(input.tc0 * textureDims.y);
    float d  = max(dot(dx, dx), dot(dy, dy));
    float mip = clamp(0.5f * log2(d) - 1, 0.0f, mipLevels.x-1); // [0..mip-1]
    dx /= pow(2, mip);
    dy /= pow(2, mip);
    float H = clamp(1.0f - 0.5f * sqrt( max(dot(dx, dx), dot(dy, dy)) ), 0.0f, 1.0f) * (80.0f/255.0f);
    float R = abs(H * 6 - 3) - 1;
    float G = 2 - abs(H * 6 - 2);
    float B = 2 - abs(H * 6 - 4);
    // NOTE: must blend in a little bit of the original fcolor, otherwise the shader compiler might optimize the original block out,
    // because it would no longer contribute to the outputs of the shader.
    fcolor = fcolor*0.001f + clamp(float4(R,G,B, 1), 0.0f, 1.0f);
#endif
}

technique base
{
	pass p0
	{
		VertexShader = vs_base();
		PixelShader = ps_base();
	}
}


cbuffer CB_BASE_TEXT : register(b0)
{
#if %SF_SOLID
    float4 cxmul;
#endif
#if %SF_TEXDENSITY
    float4 mipLevels;
#endif
#if %SF_TEXDENSITY
    float2 textureDims;
#endif
struct
{
#if %SF_TEXT || %SF_CXFORM
    float4 cxadd;
#endif
#if %SF_TEXT || %SF_CXFORM
    float4 cxmul;
#endif
#if %SF_POSITION2D
    float4 mvp[2];
#endif
#if %SF_POSITION3D
    float4 mvp[4];
#endif
} cb_base_text
#if %SF_BATCH || %SF_INSTANCED
[SF_RENDER_MAX_BATCHES]
#endif
;
};

struct PS_BASE_TEXT
{
#if %SF_CXFORM
    float4 fucxadd : TEXCOORD0;
#endif
#if %SF_CXFORM
    float4 fucxmul : TEXCOORD1;
#endif
#if %SF_TEXT || %SF_TEXUV || %SF_ATEXUV
    half2 tc0 : TEXCOORD2;
#endif
#if %SF_TEXT
    float4 vcolor : COLOR0;
#endif
#if %SF_POSITION2D || %SF_POSITION3D
    float4 vpos : SV_Position;
#endif
};

void vs_base_text(VS_INPUT input, out PS_BASE_TEXT output)
{
#if %SF_POSITION2D
    output.vpos = float4(0,0,0,1);
    output.vpos.x = dot(input.pos, cb_base_text GET_INSTANCE .mvp[0]);
    output.vpos.y = dot(input.pos, cb_base_text GET_INSTANCE .mvp[1]);
#endif
#if %SF_POSITION3D
    output.vpos.x = dot(input.pos, cb_base_text GET_INSTANCE .mvp[0]);
    output.vpos.y = dot(input.pos, cb_base_text GET_INSTANCE .mvp[1]);
    output.vpos.z = dot(input.pos, cb_base_text GET_INSTANCE .mvp[2]);
    output.vpos.w = dot(input.pos, cb_base_text GET_INSTANCE .mvp[3]);
#endif
#if %SF_TEXT
    output.vcolor = input.acolor * cb_base_text GET_INSTANCE .cxmul + cb_base_text GET_INSTANCE .cxadd;
    output.tc0 = input.atc;
#endif
#if %SF_TEXUV
      output.tc0 = input.atc;
#endif
#if %SF_ATEXUV
      output.tc0 = input.atc;
#endif
#if %SF_CXFORM
    output.fucxadd = cb_base_text GET_INSTANCE .cxadd;
    output.fucxmul = cb_base_text GET_INSTANCE .cxmul;
#endif
}

void ps_base_text(PS_BASE_TEXT input, out float4 fcolor : SV_Target0)
{
#if %SF_SOLID
    fcolor = cxmul;
#endif
#if %SF_TEXT
    float4 c = input.vcolor;
    c.a = c.a * cry_tex0.Sample(cry_sampler0, input.tc0).r;
    fcolor = c;
#endif
#if %SF_TEXUV
    fcolor = cry_tex0.Sample(cry_sampler0,input.tc0);
#endif
#if %SF_ATEXUV
    fcolor = cry_tex0.Sample(cry_sampler0,input.tc0);
    fcolor.a = cry_tex1.Sample(cry_sampler1,input.tc0).r;
#endif
#if %SF_CXFORM
    fcolor = clamp(fcolor * input.fucxmul + input.fucxadd, 0.0f, 1.0f);
#endif
#if %SF_MUL
    fcolor.rgb = fcolor.rgb * fcolor.a;
#endif
#if %SF_INV
    fcolor.rgb = float3(fcolor.a, fcolor.a, fcolor.a);
#endif
#if %SF_INVERSEGAMMA
      fcolor = fcolor;
#endif
#if %SF_TEXDENSITY
    float2 dx = ddx(input.tc0 * textureDims.x);
    float2 dy = ddy(input.tc0 * textureDims.y);
    float d  = max(dot(dx, dx), dot(dy, dy));
    float mip = clamp(0.5f * log2(d) - 1, 0.0f, mipLevels.x-1); // [0..mip-1]
    dx /= pow(2, mip);
    dy /= pow(2, mip);
    float H = clamp(1.0f - 0.5f * sqrt( max(dot(dx, dx), dot(dy, dy)) ), 0.0f, 1.0f) * (80.0f/255.0f);
    float R = abs(H * 6 - 3) - 1;
    float G = 2 - abs(H * 6 - 2);
    float B = 2 - abs(H * 6 - 4);
    // NOTE: must blend in a little bit of the original fcolor, otherwise the shader compiler might optimize the original block out,
    // because it would no longer contribute to the outputs of the shader.
    fcolor = fcolor*0.001f + clamp(float4(R,G,B, 1), 0.0f, 1.0f);
#endif
}

technique base_text
{
	pass p0
	{
		VertexShader = vs_base_text();
		PixelShader = ps_base_text();
	}
}


cbuffer CB_MASK_CLEAR : register(b0)
{
#if %SF_DEPTHMASKCLEAR
    float4 cxmul;
#endif
struct
{
#if %SF_DEPTHMASKCLEAR
    float4 mvp[2];
#endif
} cb_mask_clear
#if %SF_BATCH || %SF_INSTANCED
[SF_RENDER_MAX_BATCHES]
#endif
;
};

struct PS_MASK_CLEAR
{
#if %SF_DEPTHMASKCLEAR
    float4 vpos : SV_Position;
#endif
};

void vs_mask_clear(VS_INPUT input, out PS_MASK_CLEAR output)
{
#if %SF_DEPTHMASKCLEAR
    output.vpos = float4(0,0,1,1); // write non-zero to Z.
    output.vpos.x = dot(input.pos, cb_mask_clear GET_INSTANCE .mvp[0]);
    output.vpos.y = dot(input.pos, cb_mask_clear GET_INSTANCE .mvp[1]);
#endif
}

void ps_mask_clear(PS_MASK_CLEAR input, out float4 fcolor : SV_Target0)
{
#if %SF_DEPTHMASKCLEAR
    fcolor = cxmul;
#endif
}

technique mask_clear
{
	pass p0
	{
		VertexShader = vs_mask_clear();
		PixelShader = ps_mask_clear();
	}
}


cbuffer CB_BASE_VIDEO : register(b0)
{
#if %SF_TEXDENSITY
    float4 mipLevels;
#endif
#if %SF_TEXDENSITY
    float2 textureDims;
#endif
struct
{
#if %SF_CXFORM || %SF_CXFORMAC
    float4 cxadd;
#endif
#if %SF_CXFORM || %SF_CXFORMAC
    float4 cxmul;
#endif
#if %SF_POSITION2D
    float4 mvp[2];
#endif
#if %SF_POSITION3D
    float4 mvp[4];
#endif
#if %SF_TEXTGVERTEXONLY
    float4 texgen[2];
#endif
} cb_base_video
#if %SF_BATCH || %SF_INSTANCED
[SF_RENDER_MAX_BATCHES]
#endif
;
};

struct PS_BASE_VIDEO
{
#if %SF_FACTORS
    half4 factor : COLOR0;
#endif
#if %SF_CXFORM || %SF_CXFORMAC
    float4 fucxadd : TEXCOORD0;
#endif
#if %SF_CXFORM || %SF_CXFORMAC
    float4 fucxmul : TEXCOORD1;
#endif
#if %SF_TEXTGVERTEXONLY
    half2 tc0 : TEXCOORD2;
#endif
#if %SF_POSITION2D || %SF_POSITION3D
    float4 vpos : SV_Position;
#endif
};

void vs_base_video(VS_INPUT input, out PS_BASE_VIDEO output)
{
#if %SF_POSITION2D
    output.vpos = float4(0,0,0,1);
    output.vpos.x = dot(input.pos, cb_base_video GET_INSTANCE .mvp[0]);
    output.vpos.y = dot(input.pos, cb_base_video GET_INSTANCE .mvp[1]);
#endif
#if %SF_POSITION3D
    output.vpos.x = dot(input.pos, cb_base_video GET_INSTANCE .mvp[0]);
    output.vpos.y = dot(input.pos, cb_base_video GET_INSTANCE .mvp[1]);
    output.vpos.z = dot(input.pos, cb_base_video GET_INSTANCE .mvp[2]);
    output.vpos.w = dot(input.pos, cb_base_video GET_INSTANCE .mvp[3]);
#endif
#if %SF_TEXTGVERTEXONLY
    output.tc0.x = dot(input.pos, cb_base_video GET_INSTANCE .texgen[0]);
    output.tc0.y = dot(input.pos, cb_base_video GET_INSTANCE .texgen[1]);
#endif
#if %SF_CXFORM
    output.fucxadd = cb_base_video GET_INSTANCE .cxadd;
    output.fucxmul = cb_base_video GET_INSTANCE .cxmul;
#endif
#if %SF_CXFORMAC
    output.fucxadd = cb_base_video GET_INSTANCE .cxadd;
    output.fucxmul = cb_base_video GET_INSTANCE .cxmul;
#endif
#if %SF_FACTORS
      output.factor = input.afactor;
#endif
}

void ps_base_video(PS_BASE_VIDEO input, out float4 fcolor : SV_Target0)
{
#if %SF_YUV
    float c0 = float((cry_tex0.Sample(cry_sampler0, input.tc0).r - 16./255.) * 1.164);
    float U0 = float(cry_tex1.Sample(cry_sampler1, input.tc0).r - 128./255.);
    float V0 = float(cry_tex2.Sample(cry_sampler2, input.tc0).r - 128./255.);
    float4 c = float4(c0,c0,c0,c0);
    float4 U = float4(U0,U0,U0,U0);
    float4 V = float4(V0,V0,V0,V0);
    c += V * float4(1.596, -0.813, 0, 0);
    c += U * float4(0, -0.392, 2.017, 0);
    c.a = 1.0;
    fcolor = c;
#endif
#if %SF_YUVA
    float c0 = float((cry_tex0.Sample(cry_sampler0, input.tc0).r - 16./255.) * 1.164);
    float U0 = float(cry_tex1.Sample(cry_sampler1, input.tc0).r - 128./255.);
    float V0 = float(cry_tex2.Sample(cry_sampler2, input.tc0).r - 128./255.);
    float4 c = float4(c0,c0,c0,c0);
    float4 U = float4(U0,U0,U0,U0);
    float4 V = float4(V0,V0,V0,V0);
    c += V * float4(1.596, -0.813, 0, 0);
    c += U * float4(0, -0.392, 2.017, 0);
    c.a = cry_tex3.Sample(cry_sampler3, input.tc0).r;
    fcolor = c;
#endif
#if %SF_YUY2
    float4 yuv = cry_tex0.Sample(cry_sampler0, input.tc0);
    const float4 g_YuvOffset = float4( 0.501961, 0, 0.501961, 0);
    float4 offset = yuv - g_YuvOffset;

    fcolor.r = clamp( offset.g + 1.568648 * offset.b, 0.0, 1.0 );
    fcolor.g = clamp( offset.g - 0.186593 * offset.r - 0.466296 * offset.b, 0.0, 1.0 );
    fcolor.b = clamp( offset.g + 1.848352 * offset.r, 0.0, 1.0 );
    fcolor.a = 1.0;
#endif
#if %SF_CXFORM
    fcolor = clamp(fcolor * input.fucxmul + input.fucxadd, 0.0f, 1.0f);
#endif
#if %SF_CXFORMAC
      fcolor = (fcolor * float4(input.fucxmul.rgb,1)) * input.fucxmul.a;
      fcolor += input.fucxadd * fcolor.a;
      fcolor = clamp(fcolor, 0.0f, 1.0f);
#endif
#if %SF_EALPHA
    fcolor.a *= input.factor.a;
#endif
#if %SF_MUL
    fcolor.rgb = fcolor.rgb * fcolor.a;
#endif
#if %SF_INV
    fcolor.rgb = float3(fcolor.a, fcolor.a, fcolor.a);
#endif
#if %SF_INVERSEGAMMA
      fcolor = fcolor;
#endif
#if %SF_TEXDENSITY
    float2 dx = ddx(input.tc0 * textureDims.x);
    float2 dy = ddy(input.tc0 * textureDims.y);
    float d  = max(dot(dx, dx), dot(dy, dy));
    float mip = clamp(0.5f * log2(d) - 1, 0.0f, mipLevels.x-1); // [0..mip-1]
    dx /= pow(2, mip);
    dy /= pow(2, mip);
    float H = clamp(1.0f - 0.5f * sqrt( max(dot(dx, dx), dot(dy, dy)) ), 0.0f, 1.0f) * (80.0f/255.0f);
    float R = abs(H * 6 - 3) - 1;
    float G = 2 - abs(H * 6 - 2);
    float B = 2 - abs(H * 6 - 4);
    // NOTE: must blend in a little bit of the original fcolor, otherwise the shader compiler might optimize the original block out,
    // because it would no longer contribute to the outputs of the shader.
    fcolor = fcolor*0.001f + clamp(float4(R,G,B, 1), 0.0f, 1.0f);
#endif
}

technique base_video
{
	pass p0
	{
		VertexShader = vs_base_video();
		PixelShader = ps_base_video();
	}
}


cbuffer CB_CMATRIX : register(b0)
{
#if %SF_CMATRIXAC
    float4 cmatadd;
#endif
#if %SF_CMATRIXAC
    float4x4 cmatmul;
#endif
struct
{
#if %SF_CXFORMAC
    float4 cxadd;
#endif
#if %SF_CXFORMAC
    float4 cxmul;
#endif
#if %SF_POSITION2D
    float4 mvp[2];
#endif
#if %SF_TEXTG
    float4 texgen[2];
#endif
} cb_cmatrix
#if %SF_BATCH || %SF_INSTANCED
[SF_RENDER_MAX_BATCHES]
#endif
;
};

struct PS_CMATRIX
{
#if %SF_FACTORS
    half4 factor : COLOR0;
#endif
#if %SF_CXFORMAC
    float4 fucxadd : TEXCOORD0;
#endif
#if %SF_CXFORMAC
    float4 fucxmul : TEXCOORD1;
#endif
#if %SF_TEXTG
    half2 tc0 : TEXCOORD2;
#endif
#if %SF_POSITION2D
    float4 vpos : SV_Position;
#endif
};

void vs_cmatrix(VS_INPUT input, out PS_CMATRIX output)
{
#if %SF_POSITION2D
    output.vpos = float4(0,0,0,1);
    output.vpos.x = dot(input.pos, cb_cmatrix GET_INSTANCE .mvp[0]);
    output.vpos.y = dot(input.pos, cb_cmatrix GET_INSTANCE .mvp[1]);
#endif
#if %SF_TEXTG
    output.tc0.x = dot(input.pos, cb_cmatrix GET_INSTANCE .texgen[0]);
    output.tc0.y = dot(input.pos, cb_cmatrix GET_INSTANCE .texgen[1]);
#endif
#if %SF_CXFORMAC
    output.fucxadd = cb_cmatrix GET_INSTANCE .cxadd;
    output.fucxmul = cb_cmatrix GET_INSTANCE .cxmul;
#endif
#if %SF_FACTORS
      output.factor = input.afactor;
#endif
}

void ps_cmatrix(PS_CMATRIX input, out float4 fcolor : SV_Target0)
{
#if %SF_TEXTG
    fcolor = cry_tex0.Sample(cry_sampler0,input.tc0);
#endif
#if %SF_CMATRIXAC    
    fcolor = clamp(mul(fcolor,cmatmul) + cmatadd * clamp(fcolor.a + cmatadd.a, 0.0f, 1.0f), 0.0f, 1.0f);
#endif
#if %SF_CXFORMAC
      fcolor = (fcolor * float4(input.fucxmul.rgb,1)) * input.fucxmul.a;
      fcolor += input.fucxadd * fcolor.a;
      fcolor = clamp(fcolor, 0.0f, 1.0f);
#endif
#if %SF_EALPHA
    fcolor.a *= input.factor.a;
#endif
#if %SF_MUL
    fcolor.rgb = fcolor.rgb * fcolor.a;
#endif
#if %SF_INVERSEGAMMA
      fcolor = fcolor;
#endif
}

technique cmatrix
{
	pass p0
	{
		VertexShader = vs_cmatrix();
		PixelShader = ps_cmatrix();
	}
}


cbuffer CB_BLURS : register(b0)
{
#if %SF_BOX1 || %SF_BOX2 || %SF_BLUR
    float4 fsize;
#endif
#if %SF_BOX1 || %SF_BOX2 || %SF_BLUR
    float4 texscale;
#endif
struct
{
#if %SF_CXFORMAC
    float4 cxadd;
#endif
#if %SF_CXFORMAC
    float4 cxmul;
#endif
#if %SF_POSITION2D
    float4 mvp[2];
#endif
#if %SF_TEXTGVERTEXONLY
    float4 texgen[2];
#endif
} cb_blurs
#if %SF_BATCH || %SF_INSTANCED
[SF_RENDER_MAX_BATCHES]
#endif
;
};

struct PS_BLURS
{
#if %SF_CXFORMAC
    float4 fucxadd : TEXCOORD0;
#endif
#if %SF_CXFORMAC
    float4 fucxmul : TEXCOORD1;
#endif
#if %SF_TEXTGVERTEXONLY
    half2 tc0 : TEXCOORD2;
#endif
#if %SF_POSITION2D
    float4 vpos : SV_Position;
#endif
};

void vs_blurs(VS_INPUT input, out PS_BLURS output)
{
#if %SF_POSITION2D
    output.vpos = float4(0,0,0,1);
    output.vpos.x = dot(input.pos, cb_blurs GET_INSTANCE .mvp[0]);
    output.vpos.y = dot(input.pos, cb_blurs GET_INSTANCE .mvp[1]);
#endif
#if %SF_TEXTGVERTEXONLY
    output.tc0.x = dot(input.pos, cb_blurs GET_INSTANCE .texgen[0]);
    output.tc0.y = dot(input.pos, cb_blurs GET_INSTANCE .texgen[1]);
#endif
#if %SF_CXFORMAC
    output.fucxadd = cb_blurs GET_INSTANCE .cxadd;
    output.fucxmul = cb_blurs GET_INSTANCE .cxmul;
#endif
}

void ps_blurs(PS_BLURS input, out float4 fcolor : SV_Target0)
{
#if %SF_BOX1
      fcolor       = float4(0, 0, 0, 0);
      float4 color = float4(0, 0, 0, 0);
      for (float ix = -fsize.x; ix <= fsize.x; ix++)
      {{
        float2 i = float2(ix, ix);
#endif
#if %SF_BOX2
    fcolor       = float4(0, 0, 0, 0);
    float4 color = float4(0, 0, 0, 0);
    for (float ix = -fsize.x; ix <= fsize.x; ix++)
    {
      for (float iy = -fsize.y; iy <= fsize.y; iy++)
      {
        float2 i = float2(ix,iy);
#endif
#if %SF_BLUR
    color += cry_tex0.Sample(cry_sampler0, input.tc0 + i * texscale.xy);
    }} // EndBox1/2.
    fcolor = color * fsize.w;
#endif
#if %SF_CXFORMAC
      fcolor = (fcolor * float4(input.fucxmul.rgb,1)) * input.fucxmul.a;
      fcolor += input.fucxadd * fcolor.a;
      fcolor = clamp(fcolor, 0.0f, 1.0f);
#endif
#if %SF_MUL
    fcolor.rgb = fcolor.rgb * fcolor.a;
#endif
#if %SF_INVERSEGAMMA
      fcolor = fcolor;
#endif
}

technique blurs
{
	pass p0
	{
		VertexShader = vs_blurs();
		PixelShader = ps_blurs();
	}
}


cbuffer CB_SHADOWS : register(b0)
{
#if %SF_BOX2 || %SF_SHADOWBASE || %SF_BEVELBASE || %SF_SGRAD || %SF_SGRAD2 || %SF_OUTERBEVEL || %SF_INNERBEVEL || %SF_INNERSHADOW || %SF_FULLBEVEL
    float4 fsize;
#endif
#if %SF_SHADOWBASE || %SF_BEVELBASE
    float4 offset;
#endif
#if %SF_SCOLOR || %SF_SCOLOR2
    float4 scolor;
#endif
#if %SF_SCOLOR2
    float4 scolor2;
#endif
#if %SF_BASE || %SF_HIDEBASE
    float4 srctexscale;
#endif
#if %SF_BOX2 || %SF_SHADOWBASE || %SF_BEVELBASE
    float4 texscale;
#endif
struct
{
#if %SF_CXFORMAC
    float4 cxadd;
#endif
#if %SF_CXFORMAC
    float4 cxmul;
#endif
#if %SF_POSITION2D
    float4 mvp[2];
#endif
#if %SF_TEXTGVERTEXONLY
    float4 texgen[2];
#endif
} cb_shadows
#if %SF_BATCH || %SF_INSTANCED
[SF_RENDER_MAX_BATCHES]
#endif
;
};

struct PS_SHADOWS
{
#if %SF_CXFORMAC
    float4 fucxadd : TEXCOORD0;
#endif
#if %SF_CXFORMAC
    float4 fucxmul : TEXCOORD1;
#endif
#if %SF_TEXTGVERTEXONLY
    half2 tc0 : TEXCOORD2;
#endif
#if %SF_POSITION2D
    float4 vpos : SV_Position;
#endif
};

void vs_shadows(VS_INPUT input, out PS_SHADOWS output)
{
#if %SF_POSITION2D
    output.vpos = float4(0,0,0,1);
    output.vpos.x = dot(input.pos, cb_shadows GET_INSTANCE .mvp[0]);
    output.vpos.y = dot(input.pos, cb_shadows GET_INSTANCE .mvp[1]);
#endif
#if %SF_TEXTGVERTEXONLY
    output.tc0.x = dot(input.pos, cb_shadows GET_INSTANCE .texgen[0]);
    output.tc0.y = dot(input.pos, cb_shadows GET_INSTANCE .texgen[1]);
#endif
#if %SF_CXFORMAC
    output.fucxadd = cb_shadows GET_INSTANCE .cxadd;
    output.fucxmul = cb_shadows GET_INSTANCE .cxmul;
#endif
}

void ps_shadows(PS_SHADOWS input, out float4 fcolor : SV_Target0)
{
#if %SF_BOX2
    fcolor       = float4(0, 0, 0, 0);
    float4 color = float4(0, 0, 0, 0);
    for (float ix = -fsize.x; ix <= fsize.x; ix++)
    {
      for (float iy = -fsize.y; iy <= fsize.y; iy++)
      {
        float2 i = float2(ix,iy);
#endif
#if %SF_SHADOWBASE
    color += cry_tex0.Sample(cry_sampler0, input.tc0 + (offset.xy + i) * texscale.xy);
    }
    } // EndBox2.

    fcolor = color * fsize.w;
#endif
#if %SF_BEVELBASE
    color.a += cry_tex0.Sample(cry_sampler0, input.tc0 + (offset.xy + i) * texscale.xy).a;
    color.r += cry_tex0.Sample(cry_sampler0, input.tc0 - (offset.xy + i) * texscale.xy).a;
    }
    } // EndBox2.
    fcolor = color * fsize.w;
#endif
#if %SF_SCOLOR
    float4 shadowColor = scolor;
    float4 shadowColor2 = float4(0,0,0,0);
    fcolor.a = fcolor.a * fsize.z;
    fcolor.r = 0.0f;
#endif
#if %SF_SCOLOR2
    float4 shadowColor = scolor;
    float4 shadowColor2 = scolor2;
    fcolor.ar = (1.0 - fcolor.ar * fsize.z) - (1.0 - fcolor.ra * fsize.z);
#endif
#if %SF_SGRAD
    float4 shadowColor = cry_tex0.Sample(cry_sampler0, float2(clamp(fcolor.a* fsize.z,0.0f,1.0f), 0.0f));
    float4 shadowColor2 = float4(0,0,0,0);
    fcolor.a = shadowColor.a;
    fcolor.r = 0.0f;
    shadowColor.a = 1.0f;
#endif
#if %SF_SGRAD2
    fcolor.ar = (1.0 - fcolor.ar) - (1.0 - fcolor.ra);
    float4 shadowColor = cry_tex0.Sample(cry_sampler0,  float2(clamp(0.0f + 0.5f * (1.0f-fcolor.r * fsize.z) , 0.0f, 0.5f), 0.0f));
    float4 shadowColor2 = cry_tex0.Sample(cry_sampler0, float2(clamp(0.5f + 0.5f * fcolor.a * fsize.z, 0.5f, 1.0f), 0.0f));
    fcolor.a = shadowColor.a;
    fcolor.r = shadowColor2.a;
    shadowColor.a = 1.0f;
    shadowColor2.a = 1.0f;
#endif
#if %SF_BASE
    float4 base = cry_tex0.Sample(cry_sampler0, input.tc0 * srctexscale.xy);
    float4 baseValue = base;
#endif
#if %SF_HIDEBASE
    float4 base = cry_tex0.Sample(cry_sampler0, input.tc0 * srctexscale.xy);
    float4 baseValue = float4(0,0,0,base.a*0.0001); // Blend a miniscule amount of base in, so it doesn't get compiled out.
#endif
#if %SF_OUTERBEVEL
    float2 alphas = float2(shadowColor.a, shadowColor2.a);
    fcolor.ar = clamp(fcolor.ar, 0.0f, 1.0f) * alphas;
    fcolor = (shadowColor * fcolor.a + shadowColor2 * fcolor.r)*(1.0-base.a) + baseValue;
#endif
#if %SF_INNERBEVEL
    float2 alphas = float2(shadowColor.a, shadowColor2.a);
    fcolor.ar = clamp(fcolor.ar, 0.0f, 1.0f) * alphas;
    fcolor = (shadowColor * fcolor.a + shadowColor2 * fcolor.r + baseValue * (1.0 - fcolor.a - fcolor.r)) * base.a;
#endif
#if %SF_INNERSHADOW
    float lerpval = clamp((base.a*fsize.z - fcolor.a), 0.0f, 1.0f);
    lerpval *= shadowColor.a;
    fcolor = lerp(baseValue, shadowColor, lerpval) * base.a;
#endif
#if %SF_FULLBEVEL
    float2 alphas = float2(shadowColor.a, shadowColor2.a);
    fcolor.ar = clamp(fcolor.ar, 0.0f, 1.0f) * alphas;
    fcolor = (shadowColor * fcolor.a + shadowColor2 * fcolor.r + baseValue * (1.0 - fcolor.a - fcolor.r));
#endif
#if %SF_CXFORMAC
      fcolor = (fcolor * float4(input.fucxmul.rgb,1)) * input.fucxmul.a;
      fcolor += input.fucxadd * fcolor.a;
      fcolor = clamp(fcolor, 0.0f, 1.0f);
#endif
#if %SF_MUL
    fcolor.rgb = fcolor.rgb * fcolor.a;
#endif
#if %SF_INVERSEGAMMA
      fcolor = fcolor;
#endif
}

technique shadows
{
	pass p0
	{
		VertexShader = vs_shadows();
		PixelShader = ps_shadows();
	}
}


cbuffer CB_DISPLACEMENTMAP : register(b0)
{
#if %SF_DMCOLOR
    float4 boundColor;
#endif
#if %SF_DISPLACEMENTMAP
    float4 compx;
#endif
#if %SF_DISPLACEMENTMAP
    float4 compy;
#endif
#if %SF_DISPLACEMENTMAP
    float4 mapScale;
#endif
#if %SF_DISPLACEMENTMAP
    float4 scale;
#endif
struct
{
#if %SF_POSITION2D
    float4 mvp[2];
#endif
#if %SF_TEXTGVERTEXONLY
    float4 texgen[2];
#endif
} cb_displacementmap
#if %SF_BATCH || %SF_INSTANCED
[SF_RENDER_MAX_BATCHES]
#endif
;
};

struct PS_DISPLACEMENTMAP
{
#if %SF_TEXTGVERTEXONLY
    half2 tc0 : TEXCOORD0;
#endif
#if %SF_POSITION2D
    float4 vpos : SV_Position;
#endif
};

void vs_displacementmap(VS_INPUT input, out PS_DISPLACEMENTMAP output)
{
#if %SF_POSITION2D
    output.vpos = float4(0,0,0,1);
    output.vpos.x = dot(input.pos, cb_displacementmap GET_INSTANCE .mvp[0]);
    output.vpos.y = dot(input.pos, cb_displacementmap GET_INSTANCE .mvp[1]);
#endif
#if %SF_TEXTGVERTEXONLY
    output.tc0.x = dot(input.pos, cb_displacementmap GET_INSTANCE .texgen[0]);
    output.tc0.y = dot(input.pos, cb_displacementmap GET_INSTANCE .texgen[1]);
#endif
}

void ps_displacementmap(PS_DISPLACEMENTMAP input, out float4 fcolor : SV_Target0)
{
#if %SF_DISPLACEMENTMAP
    float2 mapTC = input.tc0*mapScale.xy - mapScale.zw;
    float mapInBoundsLowX  = step(mapTC.x, 0.0f);
    float mapInBoundsHighX = step(1.0f, mapTC.x);
    float mapInBoundsLowY  = step(mapTC.y, 0.0f);
    float mapInBoundsHighY = step(1.0f, mapTC.y);
    float mapInBounds = 1 - clamp(mapInBoundsLowX + mapInBoundsHighX + mapInBoundsLowY + mapInBoundsHighY, 0.0, 1.0f);
    float4 mapOffset = cry_tex0.Sample(cry_sampler0,mapTC * scale.zw) * mapInBounds + float4(0.5f,0.5f,0.5f,0.5f) * (1-mapInBounds);

    float2 tc1;
    float2 componentChannel;
    componentChannel.x = dot(float4(1,1,1,1), compx * mapOffset);
    componentChannel.y = dot(float4(1,1,1,1), compy * mapOffset);
    tc1 = input.tc0 + (componentChannel - 0.5f) * scale.xy;
    fcolor = cry_tex0.Sample(cry_sampler0, tc1);
#endif
#if %SF_DMIGNORE
    float srcInBoundsLowX  = step(tc1.x, 0.0f);
    float srcInBoundsHighX = step(1.0f, tc1.x);
    float srcInBoundsLowY  = step(tc1.y, 0.0f);
    float srcInBoundsHighY = step(1.0f, tc1.y);
    float srcInBounds     = 1 - clamp(srcInBoundsLowX + srcInBoundsHighX + srcInBoundsLowY + srcInBoundsHighY, 0.0, 1.0f);
    fcolor = (fcolor * srcInBounds) + cry_tex0.Sample(cry_sampler0, input.tc0) * (1-srcInBounds);
#endif
#if %SF_DMCOLOR
    float srcInBoundsLowX  = step(tc1.x, 0.0f);
    float srcInBoundsHighX = step(1.0f, tc1.x);
    float srcInBoundsLowY  = step(tc1.y, 0.0f);
    float srcInBoundsHighY = step(1.0f, tc1.y);
    float srcInBounds     = 1 - clamp(srcInBoundsLowX + srcInBoundsHighX + srcInBoundsLowY + srcInBoundsHighY, 0.0, 1.0f);
    fcolor = (fcolor * srcInBounds) + boundColor * (1-srcInBounds);
#endif
#if %SF_INVERSEGAMMA
      fcolor = fcolor;
#endif
}

technique DisplacementMap
{
	pass p0
	{
		VertexShader = vs_displacementmap();
		PixelShader = ps_displacementmap();
	}
}


cbuffer CB_DRAWABLECOPYPIXELS : register(b0)
{
struct
{
#if %SF_POSITION2D
    float4 mvp[2];
#endif
#if %SF_TEXTGTEXTGVERTEXONLY
    float4 texgen[4];
#endif
#if %SF_TEXTGTEXTGTEXTGVERTEXONLY
    float4 texgen[6];
#endif
} cb_drawablecopypixels
#if %SF_BATCH || %SF_INSTANCED
[SF_RENDER_MAX_BATCHES]
#endif
;
};

struct PS_DRAWABLECOPYPIXELS
{
#if %SF_TEXTGTEXTGVERTEXONLY || %SF_TEXTGTEXTGTEXTGVERTEXONLY
    half2 tc0 : TEXCOORD0;
#endif
#if %SF_TEXTGTEXTGVERTEXONLY || %SF_TEXTGTEXTGTEXTGVERTEXONLY
    half2 tc1 : TEXCOORD1;
#endif
#if %SF_TEXTGTEXTGTEXTGVERTEXONLY
    half2 tc2 : TEXCOORD2;
#endif
#if %SF_POSITION2D
    float4 vpos : SV_Position;
#endif
};

void vs_drawablecopypixels(VS_INPUT input, out PS_DRAWABLECOPYPIXELS output)
{
#if %SF_POSITION2D
    output.vpos = float4(0,0,0,1);
    output.vpos.x = dot(input.pos, cb_drawablecopypixels GET_INSTANCE .mvp[0]);
    output.vpos.y = dot(input.pos, cb_drawablecopypixels GET_INSTANCE .mvp[1]);
#endif
#if %SF_TEXTGTEXTGVERTEXONLY
    output.tc0.x = dot(input.pos, cb_drawablecopypixels GET_INSTANCE .texgen[0]);
    output.tc0.y = dot(input.pos, cb_drawablecopypixels GET_INSTANCE .texgen[1]);
    output.tc1.x = dot(input.pos, cb_drawablecopypixels GET_INSTANCE .texgen[2]);
    output.tc1.y = dot(input.pos, cb_drawablecopypixels GET_INSTANCE .texgen[3]);
#endif
#if %SF_TEXTGTEXTGTEXTGVERTEXONLY
    output.tc0.x = dot(input.pos, cb_drawablecopypixels GET_INSTANCE .texgen[0]);
    output.tc0.y = dot(input.pos, cb_drawablecopypixels GET_INSTANCE .texgen[1]);
    output.tc1.x = dot(input.pos, cb_drawablecopypixels GET_INSTANCE .texgen[2]);
    output.tc1.y = dot(input.pos, cb_drawablecopypixels GET_INSTANCE .texgen[3]);
    output.tc2.x = dot(input.pos, cb_drawablecopypixels GET_INSTANCE .texgen[4]);
    output.tc2.y = dot(input.pos, cb_drawablecopypixels GET_INSTANCE .texgen[5]);
#endif
}

void ps_drawablecopypixels(PS_DRAWABLECOPYPIXELS input, out float4 fcolor : SV_Target0)
{
#if %SF_DRAWABLECOPYPIXELS
    float4 fcolor_org = cry_tex0.Sample(cry_sampler0, input.tc0);
    float4 fcolor_src = cry_tex1.Sample(cry_sampler1, input.tc1);
    float inAlpha = fcolor_src.a;
#endif
#if %SF_DRAWABLECOPYPIXELSALPHA
    float4 fcolor_org = cry_tex0.Sample(cry_sampler0, input.tc0);
    float4 fcolor_src = cry_tex1.Sample(cry_sampler1, input.tc1);
    float4 fcolor_alp = cry_tex2.Sample(cry_sampler2, input.tc2);
    float inAlpha = fcolor_src.a * fcolor_alp.a;
#endif
#if %SF_INALPHA
    fcolor.a = inAlpha;
#endif
#if %SF_MERGEALPHA
    fcolor.a = lerp(inAlpha, 1.0f, fcolor_org.a);
#endif
#if %SF_NODESTALPHA
    fcolor.a = 1.0f;
#endif
#if %SF_COPYLERP
    fcolor.rgb = lerp(fcolor_org.rgb, fcolor_src.rgb, inAlpha / fcolor.a);
#endif
}

technique DrawableCopyPixels
{
	pass p0
	{
		VertexShader = vs_drawablecopypixels();
		PixelShader = ps_drawablecopypixels();
	}
}


cbuffer CB_DRAWABLEMERGE : register(b0)
{
#if %SF_DRAWABLEMERGE
    float4x4 cxmul;
#endif
#if %SF_DRAWABLEMERGE
    float4x4 cxmul1;
#endif
struct
{
#if %SF_POSITION2D
    float4 mvp[2];
#endif
#if %SF_TEXTGTEXTGVERTEXONLY
    float4 texgen[4];
#endif
} cb_drawablemerge
#if %SF_BATCH || %SF_INSTANCED
[SF_RENDER_MAX_BATCHES]
#endif
;
};

struct PS_DRAWABLEMERGE
{
#if %SF_TEXTGTEXTGVERTEXONLY
    half2 tc0 : TEXCOORD0;
#endif
#if %SF_TEXTGTEXTGVERTEXONLY
    half2 tc1 : TEXCOORD1;
#endif
#if %SF_POSITION2D
    float4 vpos : SV_Position;
#endif
};

void vs_drawablemerge(VS_INPUT input, out PS_DRAWABLEMERGE output)
{
#if %SF_POSITION2D
    output.vpos = float4(0,0,0,1);
    output.vpos.x = dot(input.pos, cb_drawablemerge GET_INSTANCE .mvp[0]);
    output.vpos.y = dot(input.pos, cb_drawablemerge GET_INSTANCE .mvp[1]);
#endif
#if %SF_TEXTGTEXTGVERTEXONLY
    output.tc0.x = dot(input.pos, cb_drawablemerge GET_INSTANCE .texgen[0]);
    output.tc0.y = dot(input.pos, cb_drawablemerge GET_INSTANCE .texgen[1]);
    output.tc1.x = dot(input.pos, cb_drawablemerge GET_INSTANCE .texgen[2]);
    output.tc1.y = dot(input.pos, cb_drawablemerge GET_INSTANCE .texgen[3]);
#endif
}

void ps_drawablemerge(PS_DRAWABLEMERGE input, out float4 fcolor : SV_Target0)
{
#if %SF_DRAWABLEMERGE
    float4 fcolor_original = cry_tex0.Sample(cry_sampler0, input.tc0);
    float4 fcolor_source   = cry_tex1.Sample(cry_sampler1, input.tc1);
    fcolor = mul(fcolor_original, cxmul) + mul(fcolor_source, cxmul1);
#endif
}

technique DrawableMerge
{
	pass p0
	{
		VertexShader = vs_drawablemerge();
		PixelShader = ps_drawablemerge();
	}
}


cbuffer CB_DRAWABLECOMPARE : register(b0)
{
struct
{
#if %SF_POSITION2D
    float4 mvp[2];
#endif
#if %SF_TEXTGTEXTGVERTEXONLY
    float4 texgen[4];
#endif
} cb_drawablecompare
#if %SF_BATCH || %SF_INSTANCED
[SF_RENDER_MAX_BATCHES]
#endif
;
};

struct PS_DRAWABLECOMPARE
{
#if %SF_TEXTGTEXTGVERTEXONLY
    half2 tc0 : TEXCOORD0;
#endif
#if %SF_TEXTGTEXTGVERTEXONLY
    half2 tc1 : TEXCOORD1;
#endif
#if %SF_POSITION2D
    float4 vpos : SV_Position;
#endif
};

void vs_drawablecompare(VS_INPUT input, out PS_DRAWABLECOMPARE output)
{
#if %SF_POSITION2D
    output.vpos = float4(0,0,0,1);
    output.vpos.x = dot(input.pos, cb_drawablecompare GET_INSTANCE .mvp[0]);
    output.vpos.y = dot(input.pos, cb_drawablecompare GET_INSTANCE .mvp[1]);
#endif
#if %SF_TEXTGTEXTGVERTEXONLY
    output.tc0.x = dot(input.pos, cb_drawablecompare GET_INSTANCE .texgen[0]);
    output.tc0.y = dot(input.pos, cb_drawablecompare GET_INSTANCE .texgen[1]);
    output.tc1.x = dot(input.pos, cb_drawablecompare GET_INSTANCE .texgen[2]);
    output.tc1.y = dot(input.pos, cb_drawablecompare GET_INSTANCE .texgen[3]);
#endif
}

void ps_drawablecompare(PS_DRAWABLECOMPARE input, out float4 fcolor : SV_Target0)
{
#if %SF_DRAWABLECOMPARE
    float4 fcolor0 = cry_tex0.Sample(cry_sampler0, input.tc0);
    float4 fcolor1 = cry_tex1.Sample(cry_sampler1, input.tc1);

    float4 diff = fcolor0 - fcolor1;
    float4 oneValue = float4(1.0f/255.0f, 1.0f/255.0f, 1.0f/255.0f, 1.0f/255.0f );
    float4 ltZero = (sign(diff)+float4(1,1,1,1))*-0.25f;
    float4 partDiff = oneValue * (sign(ltZero)+float4(1,1,1,1));
    float4 wrapDiff = frac(diff + float4(1,1,1,1)) + partDiff;
    float rgbdiff = sign(dot(wrapDiff.rgb, float3(1,1,1)));
    fcolor = lerp( float4(1,1,1, wrapDiff.a), float4(wrapDiff.rgb, 1), rgbdiff );
#endif
}

technique DrawableCompare
{
	pass p0
	{
		VertexShader = vs_drawablecompare();
		PixelShader = ps_drawablecompare();
	}
}


cbuffer CB_DRAWABLEPALETTEMAP : register(b0)
{
struct
{
#if %SF_POSITION2D
    float4 mvp[2];
#endif
#if %SF_TEXTGVERTEXONLY
    float4 texgen[2];
#endif
} cb_drawablepalettemap
#if %SF_BATCH || %SF_INSTANCED
[SF_RENDER_MAX_BATCHES]
#endif
;
};

struct PS_DRAWABLEPALETTEMAP
{
#if %SF_TEXTGVERTEXONLY
    half2 tc0 : TEXCOORD0;
#endif
#if %SF_POSITION2D
    float4 vpos : SV_Position;
#endif
};

void vs_drawablepalettemap(VS_INPUT input, out PS_DRAWABLEPALETTEMAP output)
{
#if %SF_POSITION2D
    output.vpos = float4(0,0,0,1);
    output.vpos.x = dot(input.pos, cb_drawablepalettemap GET_INSTANCE .mvp[0]);
    output.vpos.y = dot(input.pos, cb_drawablepalettemap GET_INSTANCE .mvp[1]);
#endif
#if %SF_TEXTGVERTEXONLY
    output.tc0.x = dot(input.pos, cb_drawablepalettemap GET_INSTANCE .texgen[0]);
    output.tc0.y = dot(input.pos, cb_drawablepalettemap GET_INSTANCE .texgen[1]);
#endif
}

void ps_drawablepalettemap(PS_DRAWABLEPALETTEMAP input, out float4 fcolor : SV_Target0)
{
#if %SF_DRAWABLEPALETTEMAP
    float4 fchannels = cry_tex0.Sample(cry_sampler0, input.tc0);
    fcolor  = cry_tex0.Sample(cry_sampler0, float2(fchannels.r, 0.125f));
    fcolor += cry_tex0.Sample(cry_sampler0, float2(fchannels.g, 0.375f));
    fcolor += cry_tex0.Sample(cry_sampler0, float2(fchannels.b, 0.625f));
    fcolor += cry_tex0.Sample(cry_sampler0, float2(fchannels.a, 0.875f));
#endif
}

technique DrawablePaletteMap
{
	pass p0
	{
		VertexShader = vs_drawablepalettemap();
		PixelShader = ps_drawablepalettemap();
	}
}


cbuffer CB_BLENDS : register(b0)
{
#if %SF_BLENDLIGHTEN || %SF_BLENDDARKEN || %SF_BLENDOVERLAY || %SF_BLENDHARDLIGHT || %SF_BLENDDIFFERENCE
    float4 cxadd;
#endif
#if %SF_BLENDLIGHTEN || %SF_BLENDDARKEN || %SF_BLENDOVERLAY || %SF_BLENDHARDLIGHT || %SF_BLENDDIFFERENCE
    float4 cxmul;
#endif
struct
{
#if %SF_CXFORMAC
    float4 cxadd;
#endif
#if %SF_CXFORMAC
    float4 cxmul;
#endif
#if %SF_POSITION2D
    float4 mvp[2];
#endif
#if %SF_TEXTGTEXTGVERTEXONLY
    float4 texgen[4];
#endif
} cb_blends
#if %SF_BATCH || %SF_INSTANCED
[SF_RENDER_MAX_BATCHES]
#endif
;
};

struct PS_BLENDS
{
#if %SF_CXFORMAC
    float4 fucxadd : TEXCOORD0;
#endif
#if %SF_CXFORMAC
    float4 fucxmul : TEXCOORD1;
#endif
#if %SF_TEXTGTEXTGVERTEXONLY
    half2 tc0 : TEXCOORD2;
#endif
#if %SF_TEXTGTEXTGVERTEXONLY
    half2 tc1 : TEXCOORD3;
#endif
#if %SF_POSITION2D
    float4 vpos : SV_Position;
#endif
};

void vs_blends(VS_INPUT input, out PS_BLENDS output)
{
#if %SF_POSITION2D
    output.vpos = float4(0,0,0,1);
    output.vpos.x = dot(input.pos, cb_blends GET_INSTANCE .mvp[0]);
    output.vpos.y = dot(input.pos, cb_blends GET_INSTANCE .mvp[1]);
#endif
#if %SF_TEXTGTEXTGVERTEXONLY
    output.tc0.x = dot(input.pos, cb_blends GET_INSTANCE .texgen[0]);
    output.tc0.y = dot(input.pos, cb_blends GET_INSTANCE .texgen[1]);
    output.tc1.x = dot(input.pos, cb_blends GET_INSTANCE .texgen[2]);
    output.tc1.y = dot(input.pos, cb_blends GET_INSTANCE .texgen[3]);
#endif
#if %SF_CXFORMAC
    output.fucxadd = cb_blends GET_INSTANCE .cxadd;
    output.fucxmul = cb_blends GET_INSTANCE .cxmul;
#endif
}

void ps_blends(PS_BLENDS input, out float4 fcolor : SV_Target0)
{
#if %SF_BLENDLIGHTEN
    float4 src = cry_tex0.Sample(cry_sampler0, input.tc0);
    src = clamp(src * cxmul + cxadd, 0.0f, 1.0f);
    float4 dst = cry_tex0.Sample(cry_sampler0, input.tc1);
    fcolor     = max(src,dst) * src.a + (1-src.a)*dst;
    fcolor.a   = src.a + (1.0-src.a)*dst.a;
#endif
#if %SF_BLENDDARKEN
        float4 src = cry_tex0.Sample(cry_sampler0, input.tc0);
        src = clamp(src * cxmul + cxadd, 0.0f, 1.0f);
        float4 dst = cry_tex0.Sample(cry_sampler0, input.tc1);
        float3 clr = min(src.rgb, dst.rgb);
        fcolor.rgb = (clr * (dst.a) + (1-dst.a)*src.rgb)*src.a + dst.rgb*(1-src.a);        
        fcolor.a   = src.a + (1.0-src.a)*dst.a;
#endif
#if %SF_BLENDOVERLAY
        float4 src = cry_tex0.Sample(cry_sampler0, input.tc0);
        src = clamp(src * cxmul + cxadd, 0.0f, 1.0f);
        float4 dst = cry_tex0.Sample(cry_sampler0, input.tc1);
        float3 screen = 1.0f - 2.0*(1.0f - src.rgb)*(1.0f - dst.rgb);
        float3 mult = 2.0 * src.rgb * dst.rgb;
        float3 select = step(float3(0.5, 0.5, 0.5), dst.rgb);
        fcolor.rgb = ((screen * select + mult * (float3(1,1,1) - select)) + src.rgb * (1 - dst.a)) * src.a + dst.rgb * (1 - src.a);
        fcolor.a   = src.a + (1.0-src.a)*dst.a;
#endif
#if %SF_BLENDHARDLIGHT
        float4 src = cry_tex0.Sample(cry_sampler0, input.tc0);
        src = clamp(src * cxmul + cxadd, 0.0f, 1.0f);
        float4 dst = cry_tex0.Sample(cry_sampler0, input.tc1);
        float3 screen = 1.0f - 2.0*(1.0f - src.rgb)*(1.0f - dst.rgb);
        float3 mult = 2.0 * src.rgb * dst.rgb;
        float3 select = step(float3(0.5, 0.5, 0.5), dst.rgb);
        fcolor.rgb = ((mult * select + screen * (float3(1,1,1) - select)) + src.rgb * (1 - dst.a)) * src.a + dst.rgb * (1 - src.a);
        fcolor.a   = src.a + (1.0-src.a)*dst.a;
#endif
#if %SF_BLENDDIFFERENCE
        float4 src = cry_tex0.Sample(cry_sampler0, input.tc0);
        src = clamp(src * cxmul + cxadd, 0.0f, 1.0f);
        float4 dst = cry_tex0.Sample(cry_sampler0, input.tc1);
        fcolor     = max(src - dst, dst - src)* src.a + (1-src.a)*dst;
        fcolor.a   = src.a + (1.0-src.a)*dst.a;
#endif
#if %SF_BLENDLAYER
    float alp = cry_tex0.Sample(cry_sampler0, input.tc1).a;
    fcolor    = cry_tex0.Sample(cry_sampler0, input.tc0);
    fcolor    *= alp;
#endif
#if %SF_CXFORMAC
      fcolor = (fcolor * float4(input.fucxmul.rgb,1)) * input.fucxmul.a;
      fcolor += input.fucxadd * fcolor.a;
      fcolor = clamp(fcolor, 0.0f, 1.0f);
#endif
}

technique blends
{
	pass p0
	{
		VertexShader = vs_blends();
		PixelShader = ps_blends();
	}
}

