#define RAY_TRACING_MASK_OPAQUE						0x01   

#define RAY_TRACING_SHADER_SLOT_MATERIAL	0
#define RAY_TRACING_SHADER_SLOT_SHADOW		1
#define RAY_TRACING_NUM_SHADER_SLOTS		2

cbuffer cbRayCameraMatrix : register(b0)
{
    struct
    {
        float4x4 viewProj;
        float4x4 viewInverse;
        float4x4 projInverse;
    }rayCameraMatrix;
}

RaytracingAccelerationStructure             topLevelAS: register(t1); 
StructuredBuffer<uint2>                     bindlessBufferIndex: register(t2); 
RWTexture2D<float4>                         image: register(u3); 


struct SObjVertex
{
	float3 m_pos;
	float3 m_normal;
};

StructuredBuffer<SObjVertex>  	vertices[]: register(t2,space1); 
StructuredBuffer<uint>  		    indices[] : register(t3,space1); 

struct SHitPayload
{
  float3 hitValue;
};

struct SRayTracingIntersectionAttributes
{
	uint2 packedData;

	float2 GetBarycentrics()
	{
		return asfloat(packedData);
	}

	void SetBarycentrics(float2 barycentrics)
	{
		packedData = asuint(barycentrics);
	}
};

[shader("raygeneration")] 
void RayGenMain()
{
  const uint2 rayIndex = DispatchRaysIndex().xy;
  const uint2 rayDimension = DispatchRaysDimensions().xy;

  const float2 pixelCenter = float2(rayIndex.xy) + float2(0.5,0.5);
  const float2 inUV = pixelCenter / float2(rayDimension.xy);

  float2 d = inUV * 2.0 - 1.0;

  float4 rayOrigin = mul(rayCameraMatrix.viewInverse,float4(0,0,0,1));
  float4 target = mul(rayCameraMatrix.projInverse,float4(d.x,d.y,1.0,1.0));
  float4 direction = mul(rayCameraMatrix.viewInverse,float4(normalize(target.xyz),0.0));

  RayDesc ray;
	ray.Origin = rayOrigin;
	ray.Direction = direction;
	ray.TMin = 0.001f;
	ray.TMax = 10000.0;

  uint rayFlags = RAY_FLAG_FORCE_OPAQUE; // don't run anyhit shader
  const uint instanceInclusionMask = RAY_TRACING_MASK_OPAQUE;

  SHitPayload payload = (SHitPayload)0;

  TraceRay(
		topLevelAS,   // AccelerationStructure
		rayFlags,
		instanceInclusionMask,
		RAY_TRACING_SHADER_SLOT_MATERIAL, // RayContributionToHitGroupIndex
		RAY_TRACING_NUM_SHADER_SLOTS,     // MultiplierForGeometryContributionToShaderIndex
		0,      // MissShaderIndex
		ray,    // RayDesc
		payload // Payload
	);

  image[rayIndex] = float4(payload.hitValue.xyz,1.0);
}

[shader("closesthit")] 
void ClostHitMain(inout SHitPayload payload, in SRayTracingIntersectionAttributes attributes)
{
  uint vbIndex = bindlessBufferIndex[InstanceIndex()].x;
  uint ibIndex = bindlessBufferIndex[InstanceIndex()].y;
  StructuredBuffer<SObjVertex> vertexBuffer = vertices[NonUniformResourceIndex(vbIndex)];
	StructuredBuffer<uint>  indexBuffer = indices[NonUniformResourceIndex(ibIndex)];
	SObjVertex vertex = vertexBuffer[indexBuffer[PrimitiveIndex()]];
	payload.hitValue = float3(vertex.m_pos.xyz);
}

[shader("miss")] 
void MissMain(inout SHitPayload payload)
{
	payload.hitValue = float3(0.5,0.0,0.5);
}

technique BindlessRayTracingTestTech
{
  pass p0
  {
    RayGenShaders = {RayGenMain()};
    HitGroupShaders = {ClostHitMain()};
    MissShaders = {MissMain()};
  }
}