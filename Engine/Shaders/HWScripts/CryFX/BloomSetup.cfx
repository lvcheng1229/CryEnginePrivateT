//TanGram: TiledBloom:BloomSetup

#include "Common.cfi"
#include "ShadeLib.cfi"

#define GROUP_SIZE_X    8
#define GROUP_SIZE_Y    8

#define GROUP_TILE_SIZE 8

RWTexture2D<float4> 	BloomOuputUAV 	: register(u0);
RWBuffer<uint> 			BloomMaskOutUAV : register(u1);

Texture2D<float4> 		Tx2Tx_Source  	: register(t0); 
SamplerState 			Tx2Tx_Sampler	: register(s0);

cbuffer BloomCB : register(b0)
{
	struct
	{
		float4 TexSize;
		int4 BufferSize;
	} bloomCB;
};

groupshared uint MaskInfo[GROUP_SIZE_X*GROUP_SIZE_Y*1];

[numthreads(GROUP_SIZE_X, GROUP_SIZE_Y, 1)]
void BloomSetupCS(
    uint3 GroupID : SV_GroupID,
    uint3 GroupThreadID : SV_GroupThreadID,
	uint GroupThreadIndex : SV_GroupIndex,
    uint3 DispatchThreadID : SV_DispatchThreadID
	)
{
	const float4 TexSize = bloomCB.TexSize.xyzw;

    const uint2 pixelCoord = GroupID.xy * uint2(GROUP_SIZE_X, GROUP_SIZE_Y) + GroupThreadID.xy;
    float2 pixelUV = float2((pixelCoord.x + 0.5) * TexSize.z, (pixelCoord.y + 0.5) * TexSize.w );

    if(all(pixelUV)<=1.0)
    {
        //TanGram :TiledBloom:BloomSetup:Copy From DownsampleStablePS:[BEGIN]
    
        //High quality downsampling filter to reduce bloom flickering
    	// Filter combines five 4x4 blocks (sampled bilinearly)
    	// Reduces fireflies by applying tonemapping before averaging samples for each block
    
        float4 BloomOUT = (float4)0;
    //#if %_RT_SAMPLE0	
    	const bool bKillFireflies = true;
    //#else
    	//const bool bKillFireflies = false;
    //#endif
    
    	half3 blockTL = 0, blockTR = 0, blockBR = 0, blockBL = 0;
    	half3 tex;
    
    	tex = GetTexture2DLod(Tx2Tx_Source, Tx2Tx_Sampler, pixelUV + float2(-2, -2) * TexSize.zw * 0.5,0.0).rgb;
    	if (bKillFireflies) tex /= 1 + GetLuminance(tex);
    	blockTL += tex;
    
    	tex = GetTexture2DLod(Tx2Tx_Source, Tx2Tx_Sampler, pixelUV + float2( 0, -2) * TexSize.zw * 0.5,0.0).rgb;
    	if (bKillFireflies) tex /= 1 + GetLuminance(tex);
    	blockTL += tex; blockTR += tex;
    
    	tex = GetTexture2DLod(Tx2Tx_Source, Tx2Tx_Sampler, pixelUV + float2( 2, -2) * TexSize.zw * 0.5,0.0).rgb;
    	if (bKillFireflies) tex /= 1 + GetLuminance(tex);
    	blockTR += tex;
    
    	tex = GetTexture2DLod(Tx2Tx_Source, Tx2Tx_Sampler, pixelUV + float2(-2,  0) * TexSize.zw,0.0).rgb;
    	if (bKillFireflies) tex /= 1 + GetLuminance(tex);
    	blockTL += tex; blockBL += tex;
    
    	tex = GetTexture2DLod(Tx2Tx_Source, Tx2Tx_Sampler, pixelUV + float2( 0,  0) * TexSize.zw,0.0).rgb;
    	if (bKillFireflies) tex /= 1 + GetLuminance(tex);
    	blockTL += tex; blockTR += tex; blockBR += tex; blockBL += tex;
    
    	tex = GetTexture2DLod(Tx2Tx_Source, Tx2Tx_Sampler, pixelUV + float2( 2,  0) * TexSize.zw,0.0).rgb;
    	if (bKillFireflies) tex /= 1 + GetLuminance(tex);
    	blockTR += tex; blockBR += tex;
    
    	tex = GetTexture2DLod(Tx2Tx_Source, Tx2Tx_Sampler, pixelUV + float2(-2,  2) * TexSize.zw,0.0).rgb;
    	if (bKillFireflies) tex /= 1 + GetLuminance(tex);
    	blockBL += tex;
    
    	tex = GetTexture2DLod(Tx2Tx_Source, Tx2Tx_Sampler, pixelUV + float2( 0,  2) * TexSize.zw,0.0).rgb;
    	if (bKillFireflies) tex /= 1 + GetLuminance(tex);
    	blockBL += tex; blockBR += tex;
    
    	tex = GetTexture2DLod(Tx2Tx_Source, Tx2Tx_Sampler, pixelUV + float2( 2,  2) * TexSize.zw,0.0).rgb;
    	if (bKillFireflies) tex /= 1 + GetLuminance(tex);
    	blockBR += tex;
    
    	half3 blockCC = 0;
    	tex = GetTexture2DLod(Tx2Tx_Source, Tx2Tx_Sampler, pixelUV + float2(-1, -1) * TexSize.zw,0.0).rgb;
    	if (bKillFireflies) tex /= 1 + GetLuminance(tex);
    	blockCC += tex;
    	tex = GetTexture2DLod(Tx2Tx_Source, Tx2Tx_Sampler, pixelUV + float2( 1, -1) * TexSize.zw,0.0).rgb;
    	if (bKillFireflies) tex /= 1 + GetLuminance(tex);
    	blockCC += tex;
    	tex = GetTexture2DLod(Tx2Tx_Source, Tx2Tx_Sampler, pixelUV + float2( 1,  1) * TexSize.zw,0.0).rgb;
    	if (bKillFireflies) tex /= 1 + GetLuminance(tex);
    	blockCC += tex;
    	tex = GetTexture2DLod(Tx2Tx_Source, Tx2Tx_Sampler, pixelUV + float2(-1,  1) * TexSize.zw,0.0).rgb;
    	if (bKillFireflies) tex /= 1 + GetLuminance(tex);
    	blockCC += tex;
    
    	blockTL /= 4; blockTR /= 4; blockBR /= 4; blockBL /= 4; blockCC /= 4;
    
    	if (bKillFireflies) 
    	{
    		// Convert back to uncompressed/linear range
    		blockTL /= (1 - GetLuminance(blockTL));
    		blockTR /= (1 - GetLuminance(blockTR));
    		blockBR /= (1 - GetLuminance(blockBR));
    		blockBL /= (1 - GetLuminance(blockBL));
    		blockCC /= (1 - GetLuminance(blockCC));
    	}
    
    	BloomOUT.rgb = 0.5 * blockCC + 0.125 * (blockTL + blockTR + blockBR + blockBL);
    
    	// Filter out NaNs
    	BloomOUT.rgb = all(isfinite(BloomOUT.rgb)) ? BloomOUT.rgb : float3(0, 0, 0);
		
        //TanGram :TiledBloom:BloomSetup:Copy From DownsampleStablePS:[END]

		const float BloomThreshlod = 0.4f;
		float Luminance = GetLuminance(BloomOUT.rgb);
		float4 Result = (float4)0;

		MaskInfo[GroupThreadID.y * GROUP_SIZE_X + GroupThreadID.x] = 0;

		if(Luminance > BloomThreshlod)
		{
			Result.rgb = BloomOUT.rgb;
			MaskInfo[GroupThreadID.y * GROUP_SIZE_X + GroupThreadID.x] = 1;
		}

        BloomOuputUAV[pixelCoord] = float4(Result.rgb,1.0);

		GroupMemoryBarrierWithGroupSync();

		
		[unroll]
		for (uint MipLevel = 1; MipLevel < 4; MipLevel++)
		{
			const uint TileSize = uint(GROUP_TILE_SIZE) >> MipLevel;
			const uint ReduceBankSize = TileSize * TileSize;

			[branch]
			if (GroupThreadIndex < ReduceBankSize)
			{
				uint RawMask[4];
				[unroll]
				for (uint i = 0; i < 4; i++)
				{
					uint LDSIndex = GroupThreadIndex + i * ReduceBankSize;
					RawMask[i] = MaskInfo[LDSIndex];
				}

				uint MaskCombine = RawMask[0] || RawMask[1] || RawMask[2] || RawMask[3];
				MaskInfo[GroupThreadIndex] = MaskCombine;
			}
		}

		if(GroupThreadIndex == 0)
		{
			BloomMaskOutUAV[GroupID.y * bloomCB.BufferSize.x + GroupID.x] = MaskInfo[0];
		}

    }
}

RWBuffer<uint>		BloomTileInfoGen_TileInfoUAV 				: register(u0);
RWByteAddressBuffer BloomTileInfoGen_DispatchThreadCount		: register(u1);

Buffer<uint>		BloomTileInfoGen_Mask 						: register(t0); 

cbuffer BloomTileInfoGen_CB : register(b0)
{
	struct
	{
		float4 TexSize;
		int4 BufferSize;
	} BloomTileInfoGen_CB;
};

[numthreads(GROUP_SIZE_X, GROUP_SIZE_Y, 1)]
void BloomTileInfoGenCS(
	uint3 GroupID : SV_GroupID,
    uint3 GroupThreadID : SV_GroupThreadID,
	uint GroupThreadIndex : SV_GroupIndex,
    uint3 DispatchThreadID : SV_DispatchThreadID
)
{
	if(all(DispatchThreadID == 0))
	{
		BloomTileInfoGen_DispatchThreadCount.Store3(0,uint3(0,1,1));
	}

	if(DispatchThreadID.y < (BloomTileInfoGen_CB.BufferSize.y - 1) &&
		DispatchThreadID.x < (BloomTileInfoGen_CB.BufferSize.x - 1) &&
		DispatchThreadID.y > 0 && DispatchThreadID.x > 0)
	{
		uint CIndex = DispatchThreadID.y * BloomTileInfoGen_CB.BufferSize.x + DispatchThreadID.x;
		uint LCIndex = CIndex - 1;
		uint RCIndex = CIndex + 1;
		
		uint TIndex = (DispatchThreadID.y - 1) * BloomTileInfoGen_CB.BufferSize.x + DispatchThreadID.x;
		uint LTIndex = TIndex - 1;
		uint RTIndex = TIndex + 1;

		uint BIndex = (DispatchThreadID.y +1 ) * BloomTileInfoGen_CB.BufferSize.x + DispatchThreadID.x;
		uint LBIndex = BIndex - 1;
		uint RBIndex = BIndex + 1;

		uint CValue = BloomTileInfoGen_Mask[CIndex].x;
		uint LCValue = BloomTileInfoGen_Mask[LCIndex].x;
		uint RCValue = BloomTileInfoGen_Mask[RCIndex].x;

		uint TValue = BloomTileInfoGen_Mask[TIndex].x;
		uint LTValue = BloomTileInfoGen_Mask[LTIndex].x;
		uint RTValue = BloomTileInfoGen_Mask[RTIndex].x;

		uint BValue = BloomTileInfoGen_Mask[BIndex].x;
		uint LBValue = BloomTileInfoGen_Mask[LBIndex].x;
		uint RBValue = BloomTileInfoGen_Mask[RBIndex].x;

		uint CMaskValue = CValue || LCValue || RCValue;
		uint TMaskValue = TValue || LTValue || RTValue;
		uint BMaskValue = BValue || LBValue || RBValue;

		uint MaskValue = CMaskValue || TMaskValue || BMaskValue;

		if(MaskValue)
		{
			uint PreCountOut;
			BloomTileInfoGen_DispatchThreadCount.InterlockedAdd(0, uint(1), PreCountOut);
			const uint TileIndex = (DispatchThreadID.x & 0xFFFF) | ((DispatchThreadID.y & 0xFFFF) << 16);
			BloomTileInfoGen_TileInfoUAV[PreCountOut] = TileIndex;
			//BloomTileInfoGen_TileInfoUAV[PreCountOut] = 2;
		}
	}
}

//usage VK_BUFFER_USAGE_TRANSFER_SRC_BIT | VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT | VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT
//usage VK_BUFFER_USAGE_TRANSFER_SRC_BIT | VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT | VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT


RWTexture2D<float4>	BloomFinal_OutputUAV 				: register(u0);

//Texture2D<float4> 	BloomFinal_Tx2Tx_Source  			: register(t0); 
//SamplerState 		BloomFinal_Tx2Tx_Sampler			: register(s0);

Buffer<uint>		BloomFinal_TileInfoUAV				: register(t0); 

//cbuffer BloomFinal_CB : register(b0)
//{
//	struct
//	{
//		float4 TexSize;
//		int4 BufferSize;
//	} BloomFinal_CB;
//};

[numthreads(GROUP_SIZE_X * GROUP_SIZE_Y, 1 , 1)]
void BloomFinalCS(
	uint3 GroupID : SV_GroupID,
    uint3 GroupThreadID : SV_GroupThreadID,
	uint GroupThreadIndex : SV_GroupIndex,
    uint3 DispatchThreadID : SV_DispatchThreadID
)
{
	uint TileIndex = BloomFinal_TileInfoUAV[GroupID.x].x;
	uint2 TileIndexXY = uint2(TileIndex % 16,TileIndex / 16);
	uint2 UVCoord = TileIndexXY * uint2(GROUP_SIZE_X ,GROUP_SIZE_Y) + uint2(GroupThreadIndex % GROUP_SIZE_Y , GroupThreadIndex / GROUP_SIZE_X);
	BloomFinal_OutputUAV[UVCoord] = float4(1.0,0.0,0.0,1.0);
}

technique BloomSetup
{
	pass p0
	{
		ComputeShader = BloomSetupCS();
	}
};

technique BloomTileInfoGen
{
	pass p0
	{
		ComputeShader = BloomTileInfoGenCS();
	}
};

technique BloomFinal
{
	pass p0
	{
		ComputeShader = BloomFinalCS();
	}
};