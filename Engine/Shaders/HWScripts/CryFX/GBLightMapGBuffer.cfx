struct SGeometryApp2VS
{
	float3 posistion    : POSITION3;
	float3 normal       : NORMAL; 
	float2 lightmapuv   : LIGHTMAPUV;
};

struct SGeometryVS2PS
{
  float4 position : SV_POSITION;
};

SGeometryVS2PS LightMapGBufferGenVS(SGeometryApp2VS IN )
{
  SGeometryVS2PS vs2PS = (SGeometryVS2PS) 0;;
  vs2PS.position = float4((IN.lightmapuv - float2(0.5,0.5)) * float2(2.0,-2.0),0.0,1.0);
  return vs2PS;
}

struct SLightMapGBufferOutput
{
  float4 worldPosition :SV_Target0;
  float4 worldFaceNormal :SV_Target1;
  float4 worldShadingNormal :SV_Target2;
};

SLightMapGBufferOutput LightMapGBufferGenPS(SGeometryVS2PS IN)
{
  SLightMapGBufferOutput output;
  output.worldPosition      = IN.position;
  output.worldPosition.xy /= 4096.0;

  output.worldFaceNormal    = float4(1.0,0.0,0.0,1.0);
  output.worldShadingNormal = float4(0.0,1.0,0.0,1.0);
  return output;
}

technique LightMapGBufferGenTech
{
  pass p0
  {
    VertexShader = LightMapGBufferGenVS();
	  PixelShader  = LightMapGBufferGenPS();
    ZEnable      = true;
    ZWriteEnable = false;
    CullMode     = None;
  }
}